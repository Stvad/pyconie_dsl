0:19  
Hey, everyone. My name is Vlad. And I live here in Dublin and work for Amazon, and AWS. And today, I wanted to talk about domain specific languages in Python, or doing delightfully weird things to Python. So I think it's use, it would be useful to establish what are we talking about what are domain specific languages. And to do that, we'll take a look at an example of where we would, we might want to use them. So say we have some home automation system. And what it does, it has a bunch of states and it can react to events and perform actions. So it starts from the idle state, our particular automation system, and when evening comes, it transitions to the active state, and start listening to either of the two events, either couch active or to VR, and when to use them, it transitions into the corresponding states and waits for another. And when both who and have occurred, it transitions to pizza is coming state and actually performs the pizza order. And the results of the so called reset event, the new day. So whatever machine whatever automation system is, whatever is the state or after nation system, which in addition to idle when the day comes. And some of you have not might have not is that this looks a lifelike state machine. And indeed, we can model our home automation system with a state machine. So let's say we have following set of classes are called semantic model that would represent our state machine. So we have some events, some actions that we can perform state transitions between states and the actual machine that manages all the thing. The logic of doing things is not here, but you can find it on the GitHub page of the talk that would be referenced later. So we have our generic state machine module, right. But to set up the actual automation system, the specific one that we've seen here, we need to set wire up our machine. So how we can do that? Well, one, like the most straightforward way to do that, I guess, would be to just create all the objects and wire them up together. So we create our events, our states, transitions, and add conditions to the states and add actions to the States. And finally, we create a machine. This works, but there are a few problems with this approach. First of all, it's not really clear what's going on. Like what when you look at this code, you don't form a clear mental picture of a tape machine and how it operates in your mind. You just have some imperative set of steps that you have to read through and mentally interpret to understand what's going on. And while what can we do differently, well, we can have some kind of configuration file that would define a state machine. So say we have created a yamo configuration file that defines our events, reset event, command states and transition between states.

4:59  
So you This already improves on the What have you seen before because this has clearly defined structure. So it's easier to understand, like what we want. And also we go from like instruction by instruction constructing our state machine to defining how we would want to our state machine to look like. So going from more of an imperative approach to more of a declarative approach. And arguably, this is already can be considered DSL was a yamo carrier syntax. So the problem was that is that it has some syntactic noise associated with yamo. So not much like a lot better than XML, for example, but still, yeah, so what are the things can retain? Well, as we talking about yourselves, we can construct an external DSL. What external DSL is, is fully separate language, where you define the syntax and semantics of whatever an A statement means. And so you can create language fully targeted to your particular problem. Now, you would probably have a bit more of an initial investment was doing this versus doing the yamo thing, because while you would need to learn some things about how you define the grammar of the language. And also you would use support for things like validation for yamo, or editor support for yambol, things like that. So what other things can we do? Well, other things that we might consider doing is creating an internal DSL and what internal DSL is, it's a creative application of your host language. In our case, it's heightened to represent the model that we want to represent. So again, we have a lot of the same advantages as we use prior to DSL. So actually a structure not much syntactic noise. And it's immediately clear. What's going like what are we reconstructing and we can easily form a mental picture of a state machine in our mind. So what are domain specific languages? Well, domain specific languages are computer programming languages have. And limited expressiveness focused on particular domain. Two main points here, so computer programming languages, while these cells are designed to be written and read by humans, but we want them to be executable. So it's not a free form, description or something, it's something that we can interpret and immediately execute on. And it populates. So it may limit the things that you can do, but it allows you to focus on particular problem you're trying to solve and solve it very effectively and very easily. Why we might consider using dsls. While as we've seen with our example, it can increase our productivity. So it's a lot easier to understand and write either of the DSL options that we've seen, comparing to the original imperative setup. And given that it's clear to read and understand it's less likely that we're gonna make an error when we set it up and spend some time debugging it.

9:57  
So what tada is gone. Do we have? Well, that would be an improved communication was non technical people. Again, if we remember our comparative new civilization, if you show to some non technical person, it would be a lot harder for them to understand what's going on comparing to either of our DSL options. Another thing is making reasoning about system easier. So, as we've seen, it's easier to form a clear mental picture of the state machine. In our minds, when we look at DSL, because of the structure and the way we form our statements in the results can vary into the original Miss elevation. And finally, sometimes it can help us work around limitations of the target system. So say we have a database and we want to run some analytics on top of that, and our database runs on SQL. But our rules that we want to figure out analytics for kind of complex. And so writing and reading SQL on constant basis would be kind of hard, and especially for non technical people. So what we can do is we can create a DSL that would allow us to write a business rules in some simple language, and then we can translate that into SQL.

12:01  
So here, I wanted to look at a few DSL examples on that you might have heard of seen in practice. So you'll get a better feeling of what we're talking about. So one is got theirs, which is a DSL that allows you to construct a draft diagram. So you write relationships in a textual format, and then graphics will generate something like that, as we were talking about the state machines. We have a state machine example here. So another example can be rake. For those who haven't interacted with it before. rake is a build system. Mostly popular in the Ruby world. It's an internal to yourself that allows you to define tasks Relationships between them dependencies and finally executes them. One other one that I'm sure most people have heard of, is CSS, a language that allows us to define this style of the webpages. Ah, yeah, I found, I'm fond of this example. Because it's a language that allows us to define grammars for other languages. And this particular exerpt is power part of the grammar of the language itself. So a bit of recurrence here. And another example we have here is otters before, some people might have noticed that you've been using data classes feature. So before data classes were in the standard, there were actors. And what they allow you to do is to avoid a lot of boilerplate when you create classes, so they would create an init method for you representations, hashes, etc. Right. And today, I will mostly be focusing on internal dsls. And why is that? Well, if you are just entering this world of the cells, they are an easier option to start. Because you don't have to learn about peculiarities of parsing language defining the language, Grandma, etc. and hotlines language would do a lot of this work for you. And also,

16:58  
all the tools available for the host language would be available for you to work with while you are writing your DSL and for the users of your DSL, which is great. Also, it allows you to either invoke or embed complex logic if you need to do so, which is not so trivial to do with external DSL, or configuration files. And we when we talk about internal dsls, while what are we trying to achieve with them? Basically, the main point is to provide an interface and adoption of language that would feel like well, the language expressed in the terms of your domain, and that would minimize the amount of syntactic noise you have to deal with. So we'll look at several our internal DSL techniques. They would, yeah, they might be things like providing fluent interface on top of your current models, so a bunch of functions and build their objects that help you to add structure to the way you create your model. Then other things can be creative usage of the standard syntax of the language that you're using. And some are more specific to pi 10 we can explore it the dynamic nature of the language to Yeah, we can exploit the dynamic nature of language to help us with our language needs. And we can modify the abstract syntax tree of the language to basically change the semantics of any part of Python. So let's take a look at a few of those see Marty sales. So as I mentioned, the fluid interface is kind of a theme abstraction layer functions and builder objects. That helps you to wire up the underlying model and helps the this process feel more like writing a statement in the natural language than writing process. So if we look at our original semantic model that we have for the state machine, we have our state, state machine conditions, etc. And what we can do, we can add this fluid interface layer that defines some connecting functions and connecting objects. And those are objects that would allow us to define actions, transitions and states more fluently. And so we would go from something like this, for our original recursive. Yeah, original imperative instantiation to something like this using officers interface. So here, compared to comparing it to the, what we had before, it's a lot easier to see structure of the machine, we have a lot less noise. And again, it feels more declarative. So we create a some state.

21:16  
And we have our declarative thing. It's great. So and this is not something specific to Python, you can do something like this really in any language.

22:50  
Farther, we'll look at some thing more Python specific at using some Python syntax, peculiarities or specialties, to achieve our language objectives. So first, let us look at the context managers. The thing is that you use with the width keyword. And it's a fairly simple thing. It allows you to execute code before and after provided block of code. But that basically means that you are controlling and can control the execution context. And that is kinda important and very powerful as we can, we'll see farther into the talk. So what can we do with the context managers? Well, one example can be creating a very simple HTML builds. So if we are to define a function like that, the text function that would accept the tag name, and then a printed before and after the code that would be executed within the width block, we would be able to do something like that. So we can say with that HTML, tag body respected h1, print. And that when we're going to run it, it's going to give us death. Which is kind of cool, I think. Yeah, it's simple, but it's very powerful. So what other syntax peculiarities can we use? Well, Another thing is that there are so called Magic methods in Python. And I'm sure most of you know what I'm talking about now. So, for Python objects, and implicit object behavior is driven by so called Magic methods. And they can be redefined to suit your internal VSL need. So to demonstrate that, I created a character, Canvas, DSL, really like this example, you can find this on the GitHub page of the talk. So well, what it allows you to do is to basically paintings we are with the characters, in this case, the UTF smile. So how would you use that? Basically, what I did is I redefined the operators on the Congress, character economists object. So the greater means move the pen, right? Lower means moved and less sore, move the pan up, and floor division move the pan down. And also, I've used context manager to add an ability to temporarily switch the pen. Right. So yeah, here's some excerpts from implementation. So, as I said, we define the lower than and greater than and other operators, and they perform some transformation in our position and write things and then we have a context manager to you on. Well manage our pain, value. Right, other show, condition. But there is more to find. The key chain that allows us a lot of flexibility is the fact not Python is dynamic,

29:07  
like really dynamic. So and, like really dynamic. And that allows us to change and redefine a lot of things. That's what to me possible elsewhere. So let's consider a few things that we can do. Thanks to that. One thing is that we can define the global execution context for dimatteo. So if we are to like usually you Use modules by importing them. But you don't have to do that. Instead, you can programmatically import them and execute them, providing the ground balls and the local dictionaries for them. And what that allows you to do is to define the namespace for the module, which in turn allows you to define the names that are available in your DSL. So here, from like the module that's been loaded, we can call the achieve than and beyond sir, without explicitly creating over impressing them. And also, when we write something in the module that's been loaded, it's been written into the global namespace. And so after we are done executing dimatteo, we can access that data from the loader. So this is a fairly powerful thing. So one project that you heavily uses this capabilities that uses Khan's build system is this Khan's build system that many people, some people here might have heard of? Well, when you can define the global execution context, you also can define the local execution context. So to demonstrate that I've written a context manager that allows can allow you to emulate and implicit that so you can say with in context of some object, and when you do that, the functions that are defined on that object becomes become available within the code block in the code within the code block in width statement, and you can ask them, so here, we do with in context of a dictionary, and then we can call the update function of the dictionary without calling out the name of the dictionary explicitly. And, yeah, the second with taking the different states defined that we can nest things and works fine. So how does it work? Well, there is a bit of magic here, what we do is we basically go up the stack, and we get the frame of the color, and we get the locals dictionary for it, we copy it to be able to later restart. And then we copy all the fields from the object to the color locals, then meals, and in that moment, the color code would continue to execute. And at the end, we restore locals to what they have been before. So we wouldn't get weird side effects. While other consequences of the fact that Titan is dynamic, and that we can dynamically generate fields, functions and classes,

34:02  
on our objects or meta classes, so let's consider the HTML builder that's we've seen before the context manager base HTML builder. It's interesting, but like it's not to language like we're still called like the text function each time. There's a lot of syntactic noise there, close braces, whatever. So we can improve on that. To do that, we can define the context manager as a class. And in addition to defining the enter and exit managers, that would give us the context manager functionality would define the get Archer method which would return and you build their object when we call it and what that allows us to do His to do thing is to say things like with T dot body and T dot h1, Grant, we instead of doing tag body and tag h1, which seems quite a bit cleaner,

35:25  
right? So Well, again, Python use dynamic. And we've seen several applications of that. But now we would go to even more like deeper implications of that. So what Python allows us to do is basically to modify the abstract syntax tree at the input time. And what that means is that you can literally change what any peintres syntactic construct me to extend or completely change its functionality. And that sounds a bit abstract. So let's take a look at a few example. One that I really like is a Python library that allows you to transform the pitcher operators into the functional pi. So what that does is, it will allow us to transform the code like this. And what this code does is a grouping string by the grouping the words in a string by the their character content, I mean, it's fine, but it's a bit hard to read, because it's kind of written inside out. You apply, you do displays, and then you're applied to lager to each result of the split. And then you do group paying, etc. So as we see, we execute things inside out. Instead, what we can do, if we are to use the Python module is to write the whole thing linearly. So we do the split, and we pipe it into num, we pipe it into group by and we pipe it into the Yeah, the print function of mostly. And so this is arguably a lot cleaner. Another great example is mokra. Pine, is a framework that comes from micro Python, to framer that allows you to simplify being per time a simplification. And they have a great application combo at their website, they created pink bridges Python integrated query, believe it's an illusion on link. What pinker has is basically some pie to comprehensions for some additional syntax on top of that. And so you define a query in pink, and the input time in CAD converted into the SQL alchemy query. And that is ultimately turned in the SQL which is pretty powerful, if you ask me. So with all those techniques in mind, let's take a look again at our home automation internal DSL. So what we can see here is a fully functional parts module. But we don't define or input things like events or functions like actions or conditions. So Well, as you might have guessed, we are defining the global execution context for this module. So the execution context provides all those events and other objects and functions. And then we are also providing an internal context for the states to properly define actions and transitions.

---
(times reset as it was transcribed in 2 parts)
---

0:00  
Well, as you might have guessed, we are defining the global execution context for this module. So the execution context provides all those events and other objects and functions. And then we are also providing an internal context for the states to properly define actions and transitions.

0:38  
And yeah, and another thing we can we do here is we redefine the get item operator for conditions. So we can use the indexing syntax to define the conditions from. So, this point you might be asking yourself, do I have to do all this scary and weird things to point to start creating internal yourself? And Well, the answer is no. Well, and the answer is no. Well, first of all, we've talked about simple things that we can do like fluid interfaces. So no crazy things, bots allows you to go a long way versus the purchases implementation. But even besides that, I wanted to tell you about the story when I accidentally created the DSL, even before I got interested in the whole topic. So about a year and a half ago, I needed an ability to define commands for the AWS service called System Manager around command. The duty details are not so important. But what I needed to define is the name some parameters for the command than type of the command and pointed the location of the code. And the farther library would take this and build the things that you care about. The problem is this is I wanted to create lots and lots of commands. But things like line movement or file path are fairly common parameters. And so if I'm to just use the yambol approach that we see here, I would need to duplicate it each time. And when I am to update them, I need to update them in tons of places. Also, another thing was that I wanted an ability to easily extend the commands. So to take some existing commands and maybe redefine some properties and create a new command based on that. And so what that led me to do is to create internal DSL, I didn't call it the internal DSL because I didn't know the word at that time, but you will define commands this way. So it's fairly similar to what we've seen before. But as you see, we can reuse the prompt common parameters definition common metadata definition. And after we created our command definition, we can take that object and easily build on on that to define a comment with small variations and also turned out not it a lot easier to build yet to extend the library with new functionality when you have the DSL like that. So while another thing that I wanted to do now to demonstrate to you that

4:31  
the internal the 1000 how scary it is to do some live coding and to create And ah, an extended version of HTML built DSL that we've seen before. So, let us do that. And definitely can be have two properties file and an ID.

5:38  
So we have like five minutes left. Let's see what we can do in that time. Filter. Yeah, so we define our class that would serve as well. Yeah, smell builds a DSL, we would need a tank of time to train and retain by default to be HTML. Auto for a while, the main thing that does a lot of work for us here is the context manager. So we need to define the context manager. So on Enter, we want to print our opening tag. And this tag, and on exit, we want to print our closing tank variation in that place. Right? And, yeah, we want our get otter as a starting point. So that's going to give us a new smell filter with a new tag name. And with already then, we will be able to see something live to be with the dog or the the h1 trend. Yeah, so if we are to run this, we have our HTML on this. Yeah, don't forget to make this thing long term. And probably hide. Yeah, so we have our HTML, which we can do now is to add an ability to add parameters to the tags for each sample. And to do that, we can redefine the call magic method. So it would be able to do something like this color equals red. And to do that, we need our turon dictionary on the deck. And the default would be just an empty dictionary. So when we did call, we would assign or update health problems with whatever we passed and now we would want to actually use that so right our train would be called C Yeah, join offer space and have some key 5g for a year. From our And yeah, we're on the train here. So if we are to run the whole thing now, we can fail because we don't return anything from call. And we want to. Yes, we can get the color red now. Yay. Wow, what can what else we can improve here? Well, now we are printing things straightaway, which is not great. We might and want to

10:37  
talk tore them. Yeah, oh, well, we are out of time. That's too bad.

11:11  
Right? So we are almost out of time here. As you see, doesn't take too much to build. The SL. Nothing too complicated, I think is caring. So I encourage you to go forth and build something delightfully weird and amazingly useful with Python. Thank you.
